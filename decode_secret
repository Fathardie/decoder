#! /bin/sh
# vim: set tabstop=4 syntax=sh :
#######################################################################################################
#                                                                                                     #
# decode a single encrypted value, which was encoded by AVM's cipher algorithm                        #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# Copyright (C) 2014-2017 P.HÃ¤mmerlein (peterpawn@yourfritz.de)                                       #
#                                                                                                     #
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# The script takes the string value (without the leading dollar signs) for an encoded secret value    #
# and the password to decode it (as a hexadecimal string) and processes the encrypted data. Because   #
# the encrypted value contains an additional (partial) hash value built from the clear-text data, the #
# decoded data may be validated.                                                                      #
# If decoding was successful, the decoded value is written to STDOUT. If it contains a C-style string #
# value (the last byte is NUL), the end-of-string character is cut off.                               #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# check debug option                                                                                  #
#                                                                                                     #
#######################################################################################################
nooutput=0
if [ "$1" = "-d" -o "$1" = "--debug" ]; then
	debug=1
	dbg="-d"
	shift
elif [ "$1" = "-D" -o "$1" = "--debug-only" ]; then
	debug=1
	nooutput=1
	dbg="-d"
	shift
else
	debug=0
fi
#######################################################################################################
#                                                                                                     #
# check parameters                                                                                    #
#                                                                                                     #
#######################################################################################################
if [ "$1" = "-x" -o "$1" = "--hex-output" ]; then
	hexoutput=1
	shift
else
	hexoutput=0
fi
if [ $# -ne 2 ]; then
	printf "Missing at least one argument, we need the cipher text (Base32) and a key.\n" 1>&2
	exit 1
fi
base32="$1"
if [ $(( ${#value} % 8 )) -ne 0 ]; then
	printf "The specified encoded value has a wrong length.\n" "$serial" 1>&2
	exit 1
fi
key="$2"
if [ ${#key} -ne 32 ] && [ ${#key} -ne 64 ]; then
	printf "The specified key '%s' looks bad. It should contain exactly 32 or 64 hexadecimal\ndigits and will be padded with zeroes to 32 bytes.\n" "$key" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# try to decrypt the value                                                                            #
#                                                                                                     #
#######################################################################################################
[ $debug -eq 1 ] && printf "key\t: (%03u) 0x%s\n" $(( ${#key} / 2 )) "$key" 1>&2
[ $debug -eq 1 ] && printf "base32\t: (%03u) %s\n" ${#base32} "$base32" 1>&2
encoded="$(printf "%s\n" "$base32" | crypto b32dec)"
[ $debug -eq 1 ] && printf "input\t: (%03u) 0x%s\n" $(( ${#encoded} / 2 )) "$encoded" 1>&2
iv="$(expr "$encoded" : "\(.\{32\}\).*")"
encoded="$(expr "$encoded" : ".\{32\}\(.*\)")"
[ $debug -eq 1 ] && printf "iv\t: (%03u) 0x%s\n" $(( ${#iv} / 2 )) "$iv" 1>&2
[ $debug -eq 1 ] && printf "enc'd\t: (%03u) 0x%s\n" $(( ${#encoded} / 2 )) "$encoded" 1>&2
encoded="${encoded}00"
decoded="$(printf "%s" "$encoded" | crypto aes_decrypt "$key" "$iv")"
[ $debug -eq 1 ] && printf "dec'd\t: (%03u) 0x%s\n" $(( ${#decoded} / 2 )) "$decoded" 1>&2
hash="$(expr "$decoded" : "\(.\{8\}\).*")"
#[ $debug -eq 1 ] && printf "hash\t: (%03u) %s\n" ${#hash} "$hash" 1>&2
hexsize="$(expr "$decoded" : ".\{8\}\(.\{8\}\).*")"
value="$(expr "$decoded" : ".\{16\}\(.*\)")"
size=$(printf "%s\n" "$hexsize" | crypto hex2dec)
[ $debug -eq 1 ] && printf "size\t: %u\n" $size 1>&2
if [ $size -le $(( ${#value} / 2 )) ]; then
	vhash="$(printf "%s%s\n" "$hexsize" "$value" | crypto digest -x)"
	verify="$(expr "$vhash" : "\(.\{8\}\).*")"
	if [ "$hash" = "$verify" ]; then
		[ $hexoutput -eq 0 ] && size=$(( size - 1 ))
		value="$(expr "$value" : "\(.\{$(( size * 2 ))\}\).*")"
		[ $hexoutput -eq 0 ] && value="$(printf "%s\n" "$value" | crypto hexdec)"
		if [ $debug -eq 1 ]; then
			printf "value\t: (%03u) " $size 1>&2
			[ $hexoutput -eq 1 ] && printf "0x" 1>&2
			printf "%s\n" $value 1>&2
		fi
		[ $nooutput -ne 1 ] && printf "%s\n" "$value"
		exit 0
	else
		[ $debug -eq 1 ] && printf "to hash\t: (%03u) 0x%s %s\n" $(( ( ${#hexsize} + ${#value} ) / 2 )) "$hexsize" "$value" 1>&2
		[ $debug -eq 1 ] && printf "hash\t: (%03u) 0x%s\n" $(( ${#vhash} / 2 )) "$vhash" 1>&2
	fi
fi
[ $debug -eq 1 ] && printf "Error decoding value with the specified key.\a\n" 1>&2
exit 1
#######################################################################################################
#                                                                                                     #
# no housekeeping needed                                                                              #
#                                                                                                     #
#######################################################################################################
exit $rc
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################
