#! /bin/sh
#######################################################################################################
#                                                                                                     #
# decode a single encrypted value, which was encoded by AVM's cipher algorithm                        #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# Copyright (C) 2014-2017 P.HÃ¤mmerlein (peterpawn@yourfritz.de)                                       #
#                                                                                                     #
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU  #
# General Public License as published by the Free Software Foundation; either version 2 of the        #
# License, or (at your option) any later version.                                                     #
#                                                                                                     #
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without   #
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU      #
# General Public License under http://www.gnu.org/licenses/gpl-2.0.html for more details.             #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# The script takes the string value (without the leading dollar signs) for an encoded secret value    #
# and the password to decode it (as a hexadecimal string) and processes the encrypted data. Because   #
# the encrypted value contains an additional (partial) hash value built from the clear-text data, the #
# decoded data may be validated.                                                                      #
# If decoding was successful, the decoded value is written to STDOUT. If it contains a C-style string #
# value (the last byte is NUL), the end-of-string character is cut off.                               #
#                                                                                                     #
# This script needs an OpenSSL binary with the 'dgst' function (for MD5 hashes) and knowledge of the  #
# AES-256 (CBC) encryption mode, which will be used with the 'enc -d' function.                       #
# For data conversion, the YourFritz shell script library is needed.                                  #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# check debug option                                                                                  #
#                                                                                                     #
#######################################################################################################
if [ "$1" = "-d" -o "$1" = "--debug" ]; then
	debug=1
	# ATTENTION: No output will be written to STDOUT - this is for 'test mode' only
	shift
else
	debug=0
fi
#######################################################################################################
#                                                                                                     #
# subfunctions                                                                                        #
#                                                                                                     #
#######################################################################################################
#                                                                                                     #
# import the needed functions from the YourFritz script library                                       #
#                                                                                                     #
#######################################################################################################
if [ -f "$0.yf_scriptlib" ]; then
	. $0.yf_scriptlib
else
	YF_SCRIPT_FUNCTIONS="yf_base32_decode yf_bin2hex yf_hex2bin yf_hex2dec"
	. "$YF_SCRIPT_DIR/yf_helpers"
fi
#######################################################################################################
#                                                                                                     #
# check parameters                                                                                    #
#                                                                                                     #
#######################################################################################################
if [ $# -ne 2 ]; then
	printf "Missing at least one argument, please read the description from the comment block at the beginning of this script file.\n" 1>&2
	exit 1
fi
value="$1"
if [ $(( ${#value} % 8 )) -ne 0 ]; then
	printf "The specified encoded value has a wrong length.\n" "$serial" 1>&2
	exit 1
fi
key="$2"
if [ ${#key} -ne 32 ] && [ ${#key} -ne 64 ]; then
	printf "The specified key '%s' looks bad. It should contain exactly 32 or 64 hexadecimal digits and will be padded with zeroes to 32 bytes.\n" "$key" 1>&2
	exit 1
fi
#######################################################################################################
#                                                                                                     #
# decode the encoded value from Base32 presentation to hexadecimal string and split it into IV and    #
# encoded value                                                                                       #
#                                                                                                     #
#######################################################################################################
hexval="$(printf "%s\n" "$value" | yf_base32_decode | yf_bin2hex)"
iv="$(expr "$hexval" : "\(.\{32\}\).*")"
val="$(expr "$hexval" : ".\{32\}\(.*\)")"
#######################################################################################################
#                                                                                                     #
# decode the buffer with OpenSSL binary, this will usually throw an error due to invalid length of    #
# last block, if cleartext size wasn't between 39 and 54 byte, which results in a complete block of   #
# data for the last round of decoding                                                                 #
# remark: because the call to 'EVP_DecryptFinal_ex' fails with 'bad decrypt' in case of a last buffer #
# with a full block to decode, we add some junk and the last round will complete without problems,    #
# before the final block fails with 'wrong final block length'                                        #
#                                                                                                     #
#######################################################################################################
[ $(( ${#val} % 32 )) -eq 0 ] && val="${val}00"
decval="$(printf "%s\n" "$val" | yf_hex2bin | openssl enc -d -aes256 -K $key -iv $iv 2>/dev/null | yf_bin2hex)"
#######################################################################################################
#                                                                                                     #
# split the result into hash and hashed content and recompute the hash                                #
#                                                                                                     #
#######################################################################################################
hash="$(expr "$decval" : "\(.\{8\}\).*")"
valbuf="$(expr "$decval" : ".\{8\}\(.*\)")"
valhash="$(expr "$(printf "%s\n" "$valbuf" | yf_hex2bin | openssl dgst -md5 -binary 2>/dev/null | yf_bin2hex)" : "\(.\{8\}\).*")"
if ! [ "$hash" = "$valhash" ]; then
	printf "Error decoding value, please check the specified key.\n" 1>&2
	[ $debug -ne 1 ] && exit 1
	rc=1
else
#######################################################################################################
#                                                                                                     #
# compute the hash now                                                                                #
#                                                                                                     #
#######################################################################################################
	rc=0
	len="$(yf_hex2dec "$(expr "$valbuf" : "\(.\{8\}\).*")")"
	if [ "$(expr "$valbuf" : ".\{$(( ( 4 + len - 1 ) * 2 ))\}\(..\).*")" = "00" ]; then
		len=$(( len - 1 ))
	fi
	decoded="$(expr "$valbuf" : ".\{8\}\(.\{$(( len * 2 ))\}\).*")"
#######################################################################################################
#                                                                                                     #
# write the decoded data to STDOUT                                                                    #
#                                                                                                     #
#######################################################################################################
fi
if [ $debug -eq 1 ]; then
	printf "key    : (%03u) %s\n" $(( ${#key} / 2 )) "$key" 1>&2
	printf "input  : (%03u) %s\n" $(( ${#hexval} / 2 )) "$hexval" 1>&2
	printf "iv     : (%03u) %s\n" $(( ${#iv} / 2 )) "$iv" 1>&2
	printf "encoded: (%03u) %s\n" $(( ${#val} / 2 )) "$val" 1>&2
	printf "decoded: (%03u) %s\n" $(( ${#decval} / 2 )) "$decval" 1>&2
	printf "hmac   : (%03u) %s\n" $(( ${#hash} / 2 )) "$hash" 1>&2
	printf "length :  %03u\n" "$len" 1>&2
	printf "clear  : (%03u) %s\n" $(( ${#decoded} / 2 )) "$decoded" 1>&2
else
	printf "%s\n" "$decoded" | yf_hex2bin
fi
#######################################################################################################
#                                                                                                     #
# no housekeeping needed                                                                              #
#                                                                                                     #
#######################################################################################################
exit $rc
#######################################################################################################
#                                                                                                     #
# end of script                                                                                       #
#                                                                                                     #
#######################################################################################################
